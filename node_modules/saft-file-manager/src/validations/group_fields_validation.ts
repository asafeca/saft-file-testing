import { ErrorDetail } from "../domain/models/detalheErro";
import { FieldRules } from "../domain/models/field_rules";
import { CommonValues } from "../utils/common_values";
import { StringHelper } from "../utils/string_helpers";
import { CurrentObject } from "./model/saft/current_object";

export class GroupFieldsValidation {

    public static modelRules: Array<FieldRules>
    private model: Map<string, Object>

    constructor(model: Map<string, Object>, modelRules: Array<FieldRules>) {
        GroupFieldsValidation.modelRules = modelRules
        this.model = model
    }

    validate(): Map<string, ErrorDetail> {

        return GroupFieldsValidation.validate(this.model, GroupFieldsValidation.modelRules)
    }


    private static validate(model: Map<string, Object>, rules: Array<FieldRules>): Map<string, ErrorDetail> {


        let errorList = new Map<string, ErrorDetail>()


        model.forEach((value, key) => {

            if (typeof (key) === 'undefined')

                return

            let currentError = new CurrentObject<string, string>()
            currentError.objectName = key
            currentError.objectInfo = 'item encontrado'

            let rule = GroupFieldsValidation.modelRules.find(item => item.DESIGNACAO.toLowerCase() === key.toLowerCase())

            if (typeof (value) === 'object') {

                // Is an array

                if (value.constructor === Array) {

                    let _Array = Array.from(value)

                    for (let index = 0; index < _Array.length; index++) {
                        const _model = _Array.at(index)
                        const _map = new Map<string, Object>(Object.entries(_model as Object))

                        const _errors = GroupFieldsValidation.validate(_map, GroupFieldsValidation.modelRules)

                        if (_errors.size > 0) {
                            _errors.forEach((v, k) => {
                                errorList.set(k, new ErrorDetail({ campo: v.campo, numeroLinha: v.numeroLinha, designacao: v.designacao }))
                            })
                        }

                    }

                    return

                }


                if (rule?.IS_TIPO_COMPLEXO === 1) {

                    const children = GroupFieldsValidation.modelRules.filter(child => child.ESTRUTURA_CAMPO_ID === rule?.ID)

                    const _map = new Map<string, Object>(Object.entries(value))

                    if (_map.size > 0) {

                        StringHelper.hasField({ rulesModelList: children, onMapModel: _map, errors: errorList, rule: rule })

                        const _errors = GroupFieldsValidation.validate(_map, children)

                        if (_errors.size > 0) {
                            _errors.forEach((v, k) => {
                                errorList.set(k, new ErrorDetail({ campo: v.campo, numeroLinha: v.numeroLinha, designacao: v.designacao }))
                            })
                        }

                        return

                    }
                    else {
                        if (rule.IS_OBRIGATORIO === 1) {


                            const father = GroupFieldsValidation.modelRules.find(item => item.ID === rule?.ESTRUTURA_CAMPO_ID)

                            errorList.set(key, new ErrorDetail({ campo: key, designacao: `O campo ${father?.DESIGNACAO}.${key} é inválid.`, numeroLinha: -1 }))

                            return

                        }
                    }
                }

            }

            switch (rule?.TIPO_DADO) {

                case 'String': {

                    try {

                        const father = GroupFieldsValidation.modelRules.find(item => item.ID === rule?.ESTRUTURA_CAMPO_ID)
                        if (rule.IS_OBRIGATORIO === 1) {

                            if (typeof (value) === 'undefined' || value === null)

                                errorList.set(key, new ErrorDetail({ campo: key, designacao: `O campo ${father?.DESIGNACAO}.${key} é inválido. Tamanho máximo: ${rule.TAMANHO}`, numeroLinha: -1 }))
                        }
                    }

                    catch (e) {

                        errorList.set(key, new ErrorDetail({ campo: key, designacao: `${e}`, numeroLinha: -1 }))

                    }

                    break

                }

                case 'Integer': {

                    if (!StringHelper.isInteger(value.valueOf() as string)) {

                        errorList.set(key, new ErrorDetail({ campo: key, designacao: `${key} é inválido. Deve ser inteiro. Valor encontrado: ${value}`, numeroLinha: -1 }))


                    }

                    break

                }

                case 'BigDecimal': {

                    if (!StringHelper.iSDecimal(value)) {


                        try {
                            errorList.set(key, new ErrorDetail({ campo: key, designacao: `${key} é inválido. Deve ser Decimal. Valor encontrado: ${value}`, numeroLinha: -1 }))
                        }
                        catch (e) {
                            errorList.set(key, new ErrorDetail({ campo: key, designacao: `${key}. Error: ${e}`, numeroLinha: -1 }))
                        }

                    }

                    break
                }

                case 'Boolean': {

                    if (!StringHelper.isBoolean(value.valueOf() as string)) {

                        errorList.set(key, new ErrorDetail({ campo: key, designacao: `${key} é inválido. Deve ser Boolean(true/false, 1/0). Valor encontrado: ${value}`, numeroLinha: -1 }))

                    }

                    break

                }

                case 'LocalDateTime': {

                    const _val = value.valueOf() as string

                    if (!StringHelper.iSLocalDateTime(_val)) {

                        errorList.set(key, new ErrorDetail({ campo: key, designacao: `${key} é inválido: ${value}`, numeroLinha: -1 }))

                    }

                    break




                }

                case 'LocalDate': {

                    const _val = value.valueOf() as string

                    if (!StringHelper.iSLocalDateTime(_val)) {

                        errorList.set(key, new ErrorDetail({ campo: key, designacao: `${key} é inválido: ${value}`, numeroLinha: -1 }))

                    }

                    break

                }



            }

        })


        return errorList
    }

}